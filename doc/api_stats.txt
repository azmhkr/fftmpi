"fftMPI documentation"_Manual.html

API for FFT only_1d_ffts(), only_remaps(), only_one_remap() :h3

These methods are generally only useful for performance testing or
debugging.  They perform low-level operations within the FFT.  See the
test/test3d.cpp and its timing() method for examples of how they can be
accessed and output.

The code examples at the bottom of the page are for 3d FFTs.  Just
replace "3d" by "2d" for 2d FFTs.  Note that a few of the variables
listed in the API section do not exist for 2d FFTs.

:line

API:

void only_1d_ffts(FFT_SCALAR *in, int flag);
void only_remaps(FFT_SCALAR *in, FFT_SCALAR *out, int flag);
void only_one_remap(FFT_SCALAR *in, FFT_SCALAR *out, int flag, int which); :pre

int collective,exchange,packflag; // 3 values caller can set
int64_t memusage;                 // memory usage in bytes :pre

int npfast1,npfast2,npfast3;      // size of pencil decomp in fast dim
int npmid1,npmid2,npmid3;         // ditto for mid dim
int npslow1,npslow2,npslow3;      // ditto for slow dim
int npbrick1,npbrick2,npbrick3;   // size of brick decomp in 3 dims :pre

int ntrial;                            // # of tuning trial runs
int npertrial;                         // # of FFTs per trial
int cbest,ebest,pbest;                 // fastest setting for coll,exch,pack
int cflags\[10\],eflags\[10\],pflags\[10\];  // same 3 settings for each trial
double besttime;                       // fastest single 3d FFT time
double setuptime;                      // setup() time after tuning
double tfft\[10\];                     // single 3d FFT time for each trial
double t1d\[10\];                      // 1d FFT time for each trial
double tremap\[10\];                   // total remap time for each trial
double tremap1\[10\],tremap2\[10\],tremap3\[10\],tremap4\[10\];  // per-remap time for each trial :pre

char *fft1d;                // name of 1d FFT lib
char *precision;            // precision of FFTs, "single" or "double" :pre

:line

The 3 "only" methods perform only portions of an FFT, so that they can
be timed seperately by the calling app.  The "in" and "out" pointers
have the same meaning as for the "compute() method"_api_compute.html.
The data they point to should be initialized to zero by the caller.

For only_1d_ffts(), 3 sets of 1d ffts (fast, mid, slow) are performed
if the 3d case, and 2 sets for 2d (just fast, slow).  No data
remapping is performed.  Only an "in" buffer is passed to this method,
since the 1d FFTs are always done in place.  Since a processor may own
more data at intermediate stages of the FFT than it does initially,
the data buffer should be of size "fftsize" and all be initialized to
zero.  Fftsize is the buffer length returned by the "setup()
method"_api_setup.html or "tune() method"_tune.html.

For only_remaps(), all the data remappings for the FFT are performed,
but no 1d FFTs.  The flag value is 1 for a forward FFT and -1 for an
inverse FFT, the same as the flag value for the "compute()
method"_api_compute.html.

For only_one_remap(), a single data remappings within the FFT is
performed (no 1d FFTs).  The flag value is 1 for a forward FFT and -1
for an inverse FFT.  The "which" argument is one of 1,2,3,4 for a 3d
FFT, and one of 1,2,3 for a 2d FFT.  For a forward 3d FFT, 1 = initial
remap from input layout to x-pencils, 2 = remap from x to y-pencils, 3
= remap from y to z-pencils, 4 = remap from z-pencils to output
layout.  For an inverse 3d FFT each of the which = 1,2,3,4 is the
same, except the remap is in the other direction.  E.g. which = 3 is a
remap from z to y-pencils.  A 2d FFT is the same except there is no y
to z-pencils remap for a forward FFT.

:line

The variable lines in the API section above are names of public
variables within the FFT class which can be accessed by the caller.
Their data types are one of the following: int (32-bit integer),
int64_t (64-bit integer), double (64-bit floating point), char *
(string), int *, double *.  The latter two are vectors of values.

The collective,exchange,packflag values are set by the caller (or
defaults) when using the "setup() method"_api_setup.html They are set
by fftMPI when using the "tune() method"_api_tune.html.  Memusage is
the size (on each processor) of the internal memory allocated by
fftMPI for send and receive buffers.

The 4 lines of variables that begin with "np" are info about the
processor decompositions of the global FFT grid at different stages of
the FFT.  Fast, mid, slow refer to the x, y, z-pencil decompositions
between stages of 1d FFTs.  Brick refer to a 3d brick (or 2d
rectangle) decomposition which is used when exchange = 1 (brick).
See the "setup() method"_api_setup.html doc page for details.

The large set of variables begining is output generated by the "tune()
method"_api_tune.html.  Refer to its doc page for details on trials
and FFTs/trial (npertrial).  The various input flags and timing
outputs for each trial are stored in vectors.

To access these variables from C, Fortran, Python, there is a get()
method which needs to be called.  See syntax details in the code
examples below.

:line
:line

C++:

FFT_SCALAR *work;
work = (FFT_SCALAR *) malloc(2*fftsize*sizeof(FFT_SCALAR)); :pre

fft->only_1d_ffts(work,1);
fft->only_remaps(work,work,1);
fft->only_one_remap(work,work,1,3); :pre

printf("3d FFTs with %s library, precision = %s\n",
  fft->fft1d,fft->precision); :pre

printf("Memory usage (per-proc) by fftMPI = %g MBytes\n",
       (double) fft->memusage / 1024/1024); :pre

printf("Tuning trials & iterations: %d %d\n",fft->ntrial,fft->npertrial);
for (int i = 0; i < fft->ntrial; i++)
  printf("  coll exch pack 3dFFT 1dFFT remap r1 r2 r3 r4: "
         "%d %d %d %g %g %g %g %g %g %g\n",
         fft->cflags\[i\],fft->eflags\[i\],fft->pflags\[i\],
         fft->tfft\[i\],fft->t1d\[i\],fft->tremap\[i\],
         fft->tremap1\[i\],fft->tremap2\[i\],
         fft->tremap3\[i\],fft->tremap4\[i\]); :pre

The "fft" pointer is created by instantiating an instance of the
"FFT3d class"_api_create.html.

The FFT_SCALAR datatype is defined by fftMPI to be "double" (64-bit)
or "float" (32-bit) for double-precision or single-precision FFTs.

:line

C:

void *fft;     // set by "fft3d_create()"_api_create.html
FFT_SCALAR *work;
work = (FFT_SCALAR *) malloc(2*fftsize*sizeof(FFT_SCALAR)); :pre

fft3d_only_1d_ffts(fft,work,1);
fft3d_only_remaps(fft,work,work,1);
fft3d_only_one_remap(fft,work,work,1,3); :pre

char *fft1d = (char *) fft3d_get(fft,"fft1d");
char *precision = (char *) fft3d_get(fft,"precision");
printf("3d FFTs with %s library, precision = %s\n",fft1d,precision); :pre

double memusage = (double) *((int64_t *) fft3d_get(fft,"memusage")) / 1024/1024;
printf("Memory usage (per-proc) by fftMPI = %g MBytes\n",memusage); :pre

printf("Tuning trials & iterations: %d %d\n",ntrial,npertrial);
int *cflags = (int *) fft3d_get(fft,"cflags");
int *eflags = (int *) fft3d_get(fft,"eflags");
int *pflags = (int *) fft3d_get(fft,"pflags");
double *tfft = (double *) fft3d_get(fft,"tfft");
double *t1d = (double *) fft3d_get(fft,"t1d");
double *tremap = (double *) fft3d_get(fft,"tremap");
double *tremap1 = (double *) fft3d_get(fft,"tremap1");
double *tremap2 = (double *) fft3d_get(fft,"tremap2");
double *tremap3 = (double *) fft3d_get(fft,"tremap3");
for (int i = 0; i < ntrial; i++)
  printf("  coll exch pack 3dFFT 1dFFT remap r1 r2 r3: "
         "%d %d %d %g %g %g %g %g %g\n",
         cflags\[i\],eflags\[i\],pflags\[i\],
         tfft\[i\],t1d\[i\],tremap\[i\],
         tremap1\[i\],tremap2\[i\],tremap3\[i\]); :pre

The FFT_SCALAR datatype is defined by fftMPI to be "double" (64-bit)
or "float" (32-bit) for double-precision or single-precision FFTs.

The fft3d_get() method retrieves the value of an internal public
variable.  What it returns is a "void *" pointer which needs to be
cast to the appropriate type and deferenced if necessary.  The type is
listed in the API section above for each variable.  Examples of doing
this for various variable types are illustrated in the code above.

:line

Fortran:

type(c_ptr) :: fft    ! set by "fft3d_create()"_api_create.html
real(4), allocatable, target :: work(:)      ! single precision
real(8), allocatable, target :: work(:)      ! double precision
allocate(work(2*fftsize)) :pre

call fft3d_only_1d_ffts(fft,c_loc(work),1)
call fft3d_only_remaps(fft,c_loc(work),c_loc(work),1)
call fft3d_only_one_remap(fft,c_loc(work),c_loc(work),1,3) :pre

NOTE: still need code examples for the get() functions from Fortran

The fft3d_get() methods retrieve the value of an internal public
variable.  The word after "get" is the type of the variable as stored
in the FFT class.  The type is listed in the API section above for
each variable.  Examples of doing this for various variable types are
illustrated in the code above.

:line

Python:

import numpy as np
work = np.zeros(2*fftsize,np.float32)    # single precision
work = np.zeros(2*fftsize,np.float)      # double precision :pre

fft.only_1d_ffts(work,1)
fft.only_remaps(work,work,1)
fft.only_one_remap(work,work,1,3) :pre

print "3d FFTs with %s library, precision = %s" %
  (fft.get("fft1d",4,1),fft.get("precision",4,1)) :pre

print "Memory usage (per-proc) by fftMPI = %g MBytes" %
  (float(fft.get("memusage",3,0)) / 1024/1024) :pre

print "Tuning trials & iterations: %d %d" % (ntrial,npertrial)
for i in range(ntrial):
  print "  coll exch pack 3dFFT 1dFFT remap r1 r2 r3 r4: " +
        "%d %d %d %g %g %g %g %g %g %g" %
        (fft.get("cflags",1,1)\[i\],fft.get("eflags",1,1)\[i\],
         fft.get("pflags",1,1)\[i\],fft.get("tfft",2,1)\[i\],
         fft.get("t1d",2,1)\[i\],fft.get("tremap",2,1)\[i\],
         fft.get("tremap1",2,1)\[i\],fft.get("tremap2",2,1)\[i\],
         fft.get("tremap3",2,1)\[i\],fft.get("tremap4",2,1)\[i\]) :pre

The "fft" object is created by instantiating an instance
of the "FFT3dMPI class"_api_create.html.

The get() method retrieves the value of an internal public variable.
The 2nd argument is an integer type:

type = 1 = int (32-bit)
type = 2 = double
type = 3 = int (64-bit)
type = 4 = string :ul

The 3rd argument is an integer ptrflag:

ptrflag = 0 = scalar value
flag = 1 = vector pointer :ul

If the type of the variable in the API section above is an int,
double, int64_t, or char * (string), then set ptrflag = 0.  If the
type of the variable is an "int *" or "double *", then set ptrflag =
1.  Examples of doing this for various variable types are illustrated
in the code above.
