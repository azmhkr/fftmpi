<HTML>
<P><A HREF = "Manual.html">fftMPI documentation</A>
</P>
<H3>API for FFT constructor and destructor 
</H3>
<P>These methods create and destroy an instance of the FFT3d or FFT2d
class.  The code examples are for 3d FFTs.  Just replace "3d" by "2d"
for 2d FFTs.
</P>
<P>Multiple instances can be instantiated by the calling program, e.g. if
you need to define FFTs wtih different input or output distributions
of data across processors.  The MPI communicator argument for the
constructor defines the set of processors which share the FFT data and
perform the parallel FFT.
</P>
<HR>

<P>API:
</P>
<PRE>FFT3d(MPI_Comm comm, int precision);     // constructor
~FFT3d();                                                     // destructor 
</PRE>
<P>The comm argument is an MPI communicator.  The precision argument is 1
for single-precision (two 32-bit floating point numbers = 1 complex
datum), and 2 for double-precision (two 64-bit floating point numbers
= 1 complex datum).  The precision is checked by the fftMPI library to
insure it was compiled with a matching precision.  See the
<A HREF = "compile.html">compile</A> doc page for how to compile fftMPI for single
versus double precision.
</P>
<HR>

<P>C++:
</P>
<P>#include "fft3d.h"
</P>
<P>MPI_Comm world = MPI_COMM_WORLD;
int precision = 2;
</P>
<P>FFT3d *fft = new FFT3d(world,precision);
delete fft;
</P>
<HR>

<P>C:
</P>
<P>#include "fft3d_wrap.h"
</P>
<P>MPI_Comm world = MPI_COMM_WORLD;
int precision = 2;
</P>
<P>void *fft;
fft3d_create(world,precision,&fft);
fft3d_destroy(fft);
</P>
<HR>

<P>Fortran:
</P>
<P>include 'mpif.h'
</P>
<P>use iso_c_binding
use fft3d_wrap
</P>
<P>integer world,precision
TYPE(C_ptr) :: fft
</P>
<P>world = MPI_COMM_WORLD
precision = 2
</P>
<P>call fft3d_create(world,precision,fft)
call fft3d_destroy(fft)
</P>
<HR>

<P>Python:
</P>
<P>from fftmpi import FFT3dMPI
from mpi4py import MPI
</P>
<P>world = MPI.COMM_WORLD
precision = 2
</P>
<P>fft = FFT3dMPI(world,precision)
del fft
</P>
</HTML>
