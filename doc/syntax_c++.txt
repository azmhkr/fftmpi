"fftMPI documentation"_Manual.html

Syntax for calling the library from C++ :h3

These are the methods that can be called for the FFT3d class.  Those
for the FFT2d class are identical, expect for the setup() method,
which is described below.  See the test/test3d.cpp and test/test2d.cpp
files for examples of how all these methods are called.

FFT3d(MPI_Comm comm, int precision);
FFT3d(int precision);   // NOTE: need to add this method to lib
~FFT3d(); :pre

These methods instantiate an instance of the FFT3d class.

Multiple instances can be instantiated by the calling program,
e.g. each with its own input/output layout of data.  The MPI
communicator defines the set of processors which will share the FFT
data and perform the parallel FFT.

void setup(int nfast, int nmid, int nslow,
           int in_ilo, int in_ihi, int in_jlo    , 
           int in_jhi, int in_klo, int in_khi,
           int out_ilo, int out_ihi, int out_jlo, 
           int out_jhi, int out_klo, int out_khi,
           int permute, int *fftsize, int *sendsize, int *recvsize); :pre

void setup(int nfast, int nslow,
           int in_ilo, int in_ihi, int in_jlo, int in_jhi,
           int out_ilo, int out_ihi, int out_jlo, int out_jhi,
           int permute, int *fftsize, int *sendsize, int *recvsize); :pre

void setup_memory(FFT_SCALAR *sendbuf, FFT_SCALAR *recvbuf); :pre

These methods are called one time to setup the FFT.  The first setup()
is for 3d FFTs, the second setup() is for 2d FFTs.

Nfast, nmid, nslow are the dimensions of the global FFT grid.  As
described in the "Data layout"_#data section, they refer to how the
data is stored contigously by each processor, as the fast-varyind,
mid-varying, slow-varying dimension.  This is independent of the x,y,z
spatial dimensions of the physical problem.

The in/out ijk lo/hi indices are the extent of the subsection of the
global grid that this processor owns.  Each index can be from 0 to
N-1, where N is the global grid dimension.  Again, i,j,k correspond to
fast,mid,slow, not to x,y,z.

Permute requests a permutation in storage order of fast/mid/slow on
output.  A vakue of 0 = no permutation.  A value of 1 = permute once =
mid->fast, slow->mid, fast->slow.  A value of 2 = permute twice =
slow->fast, fast->mid, mid->slow.

Three value are retured by setup().  Fftsize is the max number of FFT
grid points the processor will own at any stage of the FFT (start,
intermediate, end).  Thus it is the size of the FFT array it must
allocate.  The returned value N is the # of complex datums the
processor owns.  Thus the allocation should be 2*N doubles for
double-precision FFTs, and 2*N floats for single-precision FFTs.

Sendsize and recvsize are the size of buffers needed to perform the
MPI sends and receives for the data remapping operations.  If the
internal memoryflag value is set to 1 (the default, see description
below), the FFT library will allocate these buffers.  So the returned
values can be ignored.  If the internal memoryflag value is set to 0
by the caller, the caller must allocate the memory and pass it to the
FFT library via the setup_memory() method.  This must be done before
any FFT is computed.  The returned sendsize and recvsize values are
NOT a count of complex values, but are the # of doubles or floats that
the two buffers must be allocated for (double- or single-precision
FFTs).

void compute(FFT_SCALAR *in, FFT_SCALAR *out, int flag); :pre

This method is called as many times as desired to perform
forward and inverse FFTs.

Flag is set to 1 for forward FFTs and to -1 for inverse FFTs.  In and
out are the FFT array data allocated by the caller.  If in = out, an
in-place FFT is performed.  The size of the pointer should be
allocated to the fftsize value returned by setup(), even if that is
larger than the input or output data size.  If in != out, then "in"
only need be large enough for the initial data owned by the processor,
but "out" should be allocated to the fftsize value returned by
setup().

As discussed in the "Data layout"_#data section, in and out are
effectively pointers to 1d vectors of contiguous memory.  For
double-precision FFTs, FFT_SCALAR is a typedef to a "double".  For
single-precision FFTs, FFT_SCALAR is a typedef to a "float".  So the
caller can pass a double * or float * pointer directly.

void only_1d_ffts(FFT_SCALAR *in, int flag);
void only_remaps(FFT_SCALAR *in, FFT_SCALAR *out, int flag);
void only_one_remap(FFT_SCALAR *in, FFT_SCALAR *out, int flag, int which); :pre

These methods are generally only useful for performance testing or
debugging.  They perform low-level operations within the FFT.  See the
test3d.cpp and its timing() method for examples of how they can be
used.  NOTE: provide some more documentation here??

In addition, both the FFT3d and FFT2d classes have 6 public variables
which can be set directly to enable various FFT options.  Assume an
instance of the FFT3d (or FFT2d) class is named "fft"; the
settings can be performed in this manner:

fft->collective = 0/1/2 (default = 2), -c point/all/combo
fft->exchange = 0/1 (default = 0), -e pencil/brick
fft->packflag = 0/1/2 (default = 0), -p array/ptr/memcpy
fft->memoryflag = 0/1 (default = 1)
fft->scaled = 0/1 (default = 1)
fft->remaponly = 0/1 (default = 0) :pre

The first 4 settings must be made after the class is instantiated, but
before the setup() method is called.  The last 2 settings can be used
after setup(), but before the compute() method.

For the first 3 settings, the possible numeric values correspond to
the character strings shown for the -c, -e, -p switch options
explained above for the test program arguments.  E.g. collective = 0
is the same as -c point, collective = 1 is the same as -c all, and
collective = 2 is the same as -c combo.

If memoryflag = 1 is set, then the caller must allocate a sendbuf and
recvbuf and pass them to the library via a setup_memory() call before
the compute() method is invoked.  The required length of these buffers
is returned by the setup() method as sendsize and recvsize.

If scaled = 1 is set, then a forward FFT followed by an inverse FFT
will return values equal to the initial FFT grid values.  If scaled =
0 is set, then each final value will be a factor of N larger than the
initial value, where N = total # of points in the 2d or 3d FFT grid.

