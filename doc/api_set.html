<HTML>
<P><A HREF = "Manual.html">fftMPI documentation</A>
</P>
<H3>API for FFT setup 
</H3>
<P>In addition, both the FFT3d and FFT2d classes have 6 public variables
which can be set directly to enable various FFT options.  Assume an
instance of the FFT3d (or FFT2d) class is named "fft"; the
settings can be performed in this manner:
</P>
<P>The first 4 settings must be change before the setup() call.
The last 2 settings can be changed anytime before a compute() call.
</P>
<P>The first 4 settings must be made after the class is instantiated, but
before the setup() method is called.  The last 2 settings can be used
after setup(), but before the compute() method.
</P>
<P>For the first 3 settings, the possible numeric values correspond to
the character strings shown for the -c, -e, -p switch options
explained above for the test program arguments.  E.g. collective = 0
is the same as -c point, collective = 1 is the same as -c all, and
collective = 2 is the same as -c combo.
</P>
<P>If memoryflag = 1 is set, then the caller must allocate a sendbuf and
recvbuf and pass them to the library via a setup_memory() call before
the compute() method is invoked.  The required length of these buffers
is returned by the setup() method as sendsize and recvsize.
</P>
<P>If scaled = 1 is set, then a forward FFT followed by an inverse FFT
will return values equal to the initial FFT grid values.  If scaled =
0 is set, then each final value will be a factor of N larger than the
</P>
<HR>

<P>API:
</P>
<PRE>fft->collective = 0/1/2 (default = 2), -c point/all/combo
fft->exchange = 0/1 (default = 0), -e pencil/brick
fft->packflag = 0/1/2 (default = 0), -p array/ptr/memcpy
fft->memoryflag = 0/1 (default = 1)
fft->scaled = 0/1 (default = 1)
fft->remaponly = 0/1 (default = 0) 
</PRE>
<PRE>void setup(int user_nfast, int user_nmid, int user_nslow,
                  int user_in_ilo, int user_in_ihi, int user_in_jlo, 
                  int user_in_jhi, int user_in_klo, int user_in_khi,
                  int user_out_ilo, int user_out_ihi, int user_out_jlo, 
                  int user_out_jhi, int user_out_klo, int user_out_khi,
                  int user_permute,
                  int &user_fftsize, int &user_sendsize, int &user_recvsize) 
</PRE>
<PRE>void setup_memory(FFT_SCALAR *user_sendbuf, FFT_SCALAR *user_recvbuf) 
</PRE>
<HR>

<P>C++:
</P>
<P>int cflag,eflag,pflag,mflag,sflag,rflag;
</P>
<P>fft->collective = cflag;
fft->exchange = eflag;
fft->packflag = pflag;
fft->memoryflag = mflag;
</P>
<P>fft->scaled = sflag;
fft->remaponly = rflag;
</P>
<HR>

<P>C:
</P>
<P>int cflag,eflag,pflag,mflag,sflag,rflag;
</P>
<P>fft3d_set(fft,"collective",cflag);
fft3d_set(fft,"exchange",eflag);
fft3d_set(fft,"pack",pflag);
fft3d_set(fft,"memory",mflag);
</P>
<P>fft3d_set(fft,"scale",sflag);
fft3d_set(fft,"remaponly",rflag);
</P>
<HR>

<P>Fortran:
</P>
<P>integer cflag,eflag,pflag,mflag,sflag,rflag
</P>
<P>call fft3d_set(fft,"collective",cflag)
call fft3d_set(fft,"exchange",eflag)
call fft3d_set(fft,"pack",pflag)
call fft3d_set(fft,"memory",mflag)
</P>
<P>call fft3d_set(fft,"scale",sflag)
call fft3d_set(fft,"remaponly",rflag)
</P>
<HR>

<P>Python:
</P>
<P>cflag = 1
pflag = 0
</P>
<P>fft.set("collective",cflag)
fft.set("exchange",eflag)
fft.set("pack",pflag)
fft.set("memory",mflag)
</P>
<P>fft.set("scale",rflag)
fft.set("remaponly",rflag)
</P>
</HTML>
